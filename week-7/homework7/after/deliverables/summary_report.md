Summary Report:

The following steps were taken to secure a vulnerable containerized application. From the before file a review of the flask app showed there was a hardcoded password, pings that were not being validated as well as no prevention against injection of code. To start official scanning dbuild was used to build this app in the docker container. Make start was ran to launch the application, and then tests were run on the endpoints. With the environment running a series of scans to check for vulnerabilities and issues. From those scans it was clear the before mentioned problems were present, as well as not having the minimal base image included and no hardening of the docker. 
With all of this information in mind it was time to create the after folder to fix what was found in the before folder. To start changes were made to app.py to elimate the hardcoded passwords, validate all inputs, validate the port pings, and restricting the flask to local host. This was accomplished by putting in new code via try and except, ast.literal_eval, changing the localhost, and inputting new password inputs. To harden the docker a minimized base image was used, which ended up being 3.13-alpine. Adding a healthcheck directive to check on the security of the docker, this will help in seeing what errors or otherwise may be present. As well ensuring the app funs as a non-root user. In the docker-compose.yml file improvements were made to make the docker read only, putting in a memory limit as well as restricting port exposure and creating a .env file for secret handling. 

All of this was done to improve the architecture and align with Defense in Depth, Secure Software Development Lifecycle, and Adaptive Security Architecture. From the defense in depth model we have input several layers of protection and within those layers they are no longer stagnant making they were made to be adaptive. This is shown in the inputting of checks on the ping of the port, as well as input validation. For the SSDLC the overall process shows improvement by running scans before making changes and running them after to show improvement as well as that check for input validation to ensure there is no code injection. Another layer it the docker hardening, this provides checks directly on the container to ensure there is no attempts at breaking into that container. 

From this homework I learned quite a bit. I did have some issues initially setting everything up which ended up taking longer than actually implementing the homework which was frustrating and I still ended up with a few problems such as the base image only updating if I implemented it in both the before and after as well as my scan showing a lower score in the after even though it was higher just before recording. From the actual implementation it showed me how small changes can make a huge difference. Seeing in action how if I changed one line to make it more secure the vulnerabilities went away. From a theory standpoint I knew this was true but to see how little code it can take to harden an application it leaves me wondering why organizations do not implement such simple fixes. I also learned in that same breath that just fixing part of the code does not mean you are fully hardened and it can take several pieces for everything to work in harmony, such as the docker hardening, I struggled with the multi-stage builds but I can see how even with the other three pieces having that piece would make this code even more secure. Overall I am still learning with the hands on pieces and connecting all of the dots but it is all starting to make sense from the hands on side to the theory side of architecture as to why things have to happen in a certain order or why one piece of security is not enough you also needs to add on other pieces. 
